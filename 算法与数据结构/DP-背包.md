# DP-背包
## 0/1背包
### 问题
`n`种物品（每种物品只有1件），每种物品的价值为`v`，重量为`w`，现在有一个容量（承重量）为`W`的背包，问如何选择让背包中的物品价值最大。
### 思路
按照从前到后的顺序逐个考虑每个物品，在第$i$步，考虑物品$i$，此时有两个选择：
* 装入物品$i$。剩下的子问题是“如何在背包剩余容量为$j-w_i$的前提下，在前$i-1$个物品中找出价值最大的子集”。
* 不装入物品$i$。剩下的子问题是”如何在背包剩余容量为$j$的前提下，在前$i-1$个物品中找出价值最大的子集“。

这里使用$dp[i][j]$来表示前$i$件物品放入容量为$j$的背包时取得的最大价值。递归关系与步骤如下：

$$
dp[i][j] = 
\begin{cases}
dp[i-1][j] & j < w_i \\
max(dp[i-1][j], dp[i-1][j-w_i]) & j >= w_i
\end{cases}
$$

$dp[i][j]$为前$i$件物品放入容量为$j$的背包的最优解，则对于第$i$件物品，不放的话为$dp[i-1][j]$，放的话为$dp[i-1][j-w_i]$。
### 代码实现
```java
private static int iterativeKnapsack(int N, int W, int[] value, int[] weight) {

    if (W <= 0 || value == null || weight == null || weight.length <= 0 || N != value.length || N != weight.length)
        return -1;

    int[][] OPT = new int[N+1][W+1];

    for (int w = 0; w < W + 1; w++) {
        OPT[0][w] = 0;
    }

    // 共有N件物品
    for (int i = 1; i < N + 1; i++) {
        // 总重量为W
        for (int w = 1; w < W + 1; w++) {
            if (w >= weight[i - 1]) {
                // 如果不添加这件物品，返回上一个状态，添加则上一个状态加上新增的物品价值
                OPT[i][w] = Math.max(OPT[i - 1][w], OPT[i - 1][w - weight[i - 1]] + value[i - 1]);
            }
            else {
                OPT[i][w] = OPT[i - 1][w];
            }
        }
    }

    return OPT[N][W];
}
```
复杂度：
* 时间复杂度：$O(nw)$
* 空间复杂度：$O(nw)$
### 空间复杂度优化
```java
// 共有N件物品
for (int i = 1; i <= N; i++) {
    // 总重量为W
    for (int j = W; j >= weight[i - 1]; j--) {
        OPT[j] = Math.max(OPT[j], OPT[j - weight[i - 1]] + value[i - 1]);
    }
}
```
观察上面的代码可以发现，当前的状态$S_i$只与上一个状态$S_{i-1}$有关，第$i$次循环时，$dp[0\cdots W]$此时还没有更新，也就是保存了状态$S_{i-1}$。

注意这里内循环必须是逆序的，当前状态$S_i$依赖于上一个状态$S_{i-1}$，考虑$dp[j-w_i]$，逆序循环时前面的一定是前一个状态$S_{i-1}$。如果正序循环，$j$逐渐递增，$dp[0\cdots j]$此时已经从状态$S_{i-1}$更新成状态$S_i$了，而我们还需要状态$S_{i-1}$来计算$dp[j-w_i]$。
### 初始化细节问题
背包问题不相同的问法：
* 恰好装满背包的最优解，初始化除了$dp[0]$为$0$之外，$dp[1\cdots W]$都设为$-\infty$。
* 并没有要求把背包装满，只希望价格尽量大，初始化应该将$dp[0\cdots W$都设为0。

原因：
初始化的$dp$数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。这个小技巧完全可以推广到其它类型的背包问题。
## 完全背包
内循环为正序，这是因为每次用的状态$S_{i-1}$都是当前状态$S_i$。
## 多重背包

## 参考
卜东波，张家琳，《算法讲义-关于问题求解方法的十八讲》

[背包详解（0-1背包，完全背包，多重背包）](https://www.cnblogs.com/jk17211764/p/9677399.html)

[背包问题九讲](https://www.kancloud.cn/kancloud/pack/70124)