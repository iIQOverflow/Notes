# 共识协议和同步操作
## 引言
* 多读多写原子寄存器可以实现任意有穷多个线程对共享内存的“读”和“写”可以原子（可线性化）地执行。
* 共识就是当多个线程发生并发访问冲突时，先达成共识（非阻塞地）确定其中唯一一个线程先执行，其它线程随后执行

wait-free 的共识协议可以保证每个线程都能在有穷步内终止。一致且有效的共识协议可以保证**所有线程在终止时都能得到（即决定）一个相同的值（一致性）**，而且该值一定是其中某个线程的输入（有效性），其中winner可以执行某些操作，但是所有的loser都会知道是哪一个winner赢得了这次比赛。

**只通过读写寄存器不能实现无等待的n-线程共识协议。**

即便你失败了，也要让你知道获胜者是谁！

每个线程都会先声明自己需要帮助
```java
public Response apply(Invoc invoc) {
    int i = ThreadID.get();
    announce[i] = new Node(invoc); // 宣布新 调用，寻求帮助 。
    head[i] = Node.max(head); // 只读一次
    while (announce[i].seq == 0) {
```

每个线程都乐于助人（help），如果有需要帮助的结点，那么添加需要帮助的结点，否则添加自己的结点。


## 参考
[关于共识机制的一些想法](https://ethfans.org/topics/182)
